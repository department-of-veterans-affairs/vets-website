import { useCallback, useEffect, useMemo, useState } from 'react';
import {
  PDF_TXT_GENERATE_STATUS,
  DOWNLOAD_FORMAT,
  PRINT_FORMAT,
  DATETIME_FORMATS,
} from '../util/constants';
import {
  buildPrescriptionsPDFList,
  buildAllergiesPDFList,
} from '../util/pdfConfigs';
import {
  buildPrescriptionsTXT,
  buildAllergiesTXT,
} from '../util/txtConfigs';
import {
  dateFormat,
  displayHeaderPrefaceText,
  displayMedicationsListHeader,
  generateTextFile,
  generateTimestampForFilename,
} from '../util/helpers';
import { buildPdfData } from '../util/buildPdfData';
import { generateMedicationsPdfFile } from '../util/generateMedicationsPdfFile';

/**
 * Hook to manage generating PDF/TXT/print exports for prescriptions list.
 * Consumers supply user info, allergies data, feature flags, and a fetcher for the export list.
 */
const useRxListExport = ({
  user,
  allergies,
  allergiesError,
  selectedFilterOption,
  selectedSortOption,
  currentFilterOptions = {},
  features = {},
  fetchExportList,
}) => {
  const { isCernerPilot = false, isV2StatusMapping = false } = features;
  const [exportList, setExportList] = useState([]);
  const [printList, setPrintList] = useState([]);
  const [shouldPrint, setShouldPrint] = useState(false);
  const [status, setStatus] = useState({
    status: PDF_TXT_GENERATE_STATUS.NotStarted,
    format: undefined,
  });
  const [exportListError, setExportListError] = useState(false);
  const [errorFormat, setErrorFormat] = useState(undefined);

  const resetExportState = useCallback(() => {
    setExportList([]);
    setPrintList([]);
    setShouldPrint(false);
    setExportListError(false);
    setErrorFormat(undefined);
    setStatus({ status: PDF_TXT_GENERATE_STATUS.NotStarted, format: undefined });
  }, []);

  const isLoading = useMemo(
    () =>
      status.status === PDF_TXT_GENERATE_STATUS.InProgress && !allergiesError && !exportListError,
    [status, allergiesError, exportListError],
  );

  const isSuccess = useMemo(
    () => status.status === PDF_TXT_GENERATE_STATUS.Success,
    [status],
  );

  const hasError = useMemo(
    () =>
      (status.status === PDF_TXT_GENERATE_STATUS.InProgress && allergiesError) ||
      exportListError,
    [status, allergiesError, exportListError],
  );

  // Compute the effective error format - use status.format when there's an allergies error
  // since the errorFormat state may not be set yet
  const effectiveErrorFormat = useMemo(
    () =>
      errorFormat ||
      (status.status === PDF_TXT_GENERATE_STATUS.InProgress && allergiesError
        ? status.format
        : undefined),
    [errorFormat, status, allergiesError],
  );

  const buildTxtData = useCallback(
    (rxList, allergiesList) => {
      return (
        `${"\nIf you're ever in crisis and need to talk with someone right away, call the Veterans Crisis Line at 988. Then select 1.\n\n\n" +
          'Medications\n\n'}${
          user.first ? `${user.last}, ${user.first}` : user.last || ' '
        }\n\n` +
        `Date of birth: ${dateFormat(
          user.dob,
          DATETIME_FORMATS.longMonthDate,
        )}\n\n` +
        `Report generated by My HealtheVet on VA.gov on ${dateFormat(
          Date.now(),
          DATETIME_FORMATS.longMonthDate,
        )}\n\n` +
        `${displayHeaderPrefaceText(
          selectedFilterOption,
          selectedSortOption,
          rxList?.length,
          false,
        )}\n\n\n` +
        `${displayMedicationsListHeader(
          selectedFilterOption,
          isCernerPilot,
          isV2StatusMapping,
          currentFilterOptions,
        )}\n\n` +
        `${rxList}${allergiesList ?? ''}`
      );
    },
    [
      user,
      selectedFilterOption,
      selectedSortOption,
      isCernerPilot,
      isV2StatusMapping,
      currentFilterOptions,
    ],
  );

  const finalizeSuccess = useCallback(() => {
    setStatus({ status: PDF_TXT_GENERATE_STATUS.Success, format: status.format });
  }, [status.format]);

  const handleGenerationError = useCallback(() => {
    setExportListError(true);
    setErrorFormat(status.format);
    setStatus({ status: PDF_TXT_GENERATE_STATUS.NotStarted, format: status.format });
  }, [status.format]);

  const handlePdfGeneration = useCallback(
    async (rxList, allergiesList) => {
      const pdfDataObj = buildPdfData({
        userName: user,
        dob: user.dob,
        selectedFilterOption,
        selectedSortOption,
        rxList,
        allergiesList,
      });

      await generateMedicationsPdfFile({ userName: user, pdfData: pdfDataObj });
      finalizeSuccess();
    },
    [
      user,
      selectedFilterOption,
      selectedSortOption,
      finalizeSuccess,
    ],
  );

  const handleTxtGeneration = useCallback(
    (rxList, allergiesList) => {
      generateTextFile(
        buildTxtData(rxList, allergiesList),
        `VA-medications-list-${
          user.first ? `${user.first}-${user.last}` : user.last
        }-${generateTimestampForFilename()}`,
      );
      finalizeSuccess();
    },
    [user, buildTxtData, finalizeSuccess],
  );

  const onDownload = useCallback(
    async format => {
      setExportListError(false);
      setErrorFormat(undefined);
      setStatus({ status: PDF_TXT_GENERATE_STATUS.InProgress, format });

      if (!exportList.length && fetchExportList) {
        const { data, isError } = await fetchExportList();

        if (isError) {
          setExportListError(true);
          setErrorFormat(format);
          setStatus({ status: PDF_TXT_GENERATE_STATUS.NotStarted, format });
          return;
        }

        if (data?.prescriptions) {
          setExportList(data.prescriptions);
        }
      } else if (!exportList.length && !fetchExportList) {
        setExportListError(true);
        setErrorFormat(format);
        setStatus({ status: PDF_TXT_GENERATE_STATUS.NotStarted, format });
      }
    },
    [exportList.length, fetchExportList],
  );

  useEffect(
    () => {
      const isInProgress = status.status === PDF_TXT_GENERATE_STATUS.InProgress;
      if (!isInProgress) return;

      const format = status.format;
      const exportReady = !!exportList?.length;
      const allergiesReady = !!allergies && !allergiesError;

      if (!exportReady) return;

      if (format === PRINT_FORMAT.PRINT) {
        setPrintList(exportList);
        setStatus({ status: PDF_TXT_GENERATE_STATUS.NotStarted, format: undefined });
        setShouldPrint(true);
        return;
      }

      if (!allergiesReady) return;

      if (format === DOWNLOAD_FORMAT.PDF) {
        const runPdf = async () => {
          try {
            await handlePdfGeneration(
              buildPrescriptionsPDFList(
                exportList,
                isCernerPilot,
                isV2StatusMapping,
              ),
              buildAllergiesPDFList(allergies),
            );
          } catch (error) {
            handleGenerationError();
          }
        };

        runPdf();
      } else if (format === DOWNLOAD_FORMAT.TXT) {
        try {
          handleTxtGeneration(
            buildPrescriptionsTXT(
              exportList,
              isCernerPilot,
              isV2StatusMapping,
            ),
            buildAllergiesTXT(allergies),
          );
        } catch (error) {
          handleGenerationError();
        }
      }
    },
    [
      status,
      exportList,
      allergies,
      allergiesError,
      handlePdfGeneration,
      handleTxtGeneration,
      isCernerPilot,
      isV2StatusMapping,
      handleGenerationError,
    ],
  );

  return {
    onDownload,
    status,
    isLoading,
    isSuccess,
    hasError,
    errorFormat: effectiveErrorFormat,
    shouldPrint,
    printList,
    exportList,
    resetExportState,
    clearPrintTrigger: () => setShouldPrint(false),
  };
};

export default useRxListExport;
