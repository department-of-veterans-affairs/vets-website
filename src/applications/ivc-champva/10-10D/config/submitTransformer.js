import { transformForSubmit as formsSystemTransformForSubmit } from 'platform/forms-system/src/js/helpers';
import { FILE_UPLOAD_ORDER, REQUIRED_FILES } from './constants';
import {
  adjustYearString,
  concatStreets,
  getAgeInYears,
} from '../../shared/utilities';

// Rearranges date string from YYYY-MM-DD to MM-DD-YYYY
function fmtDate(date) {
  return date?.length && date.length === 10
    ? `${date.slice(5)}-${date.slice(0, 4)}`
    : date;
}

// Returns list of object keys where obj[key] === true. Used
// to get the list of relationships a certifier has w/ the applicants:
function trueKeysOnly(obj) {
  return Object.keys(obj ?? {}).filter(k => obj[k] === true);
}

// Simplify a relationship object from (potentially) multiple nested objects to a single string
function transformRelationship(obj) {
  if (typeof obj === 'string') return obj;
  let rel = obj?.relationshipToVeteran;
  // Check if relationshipToVeteran is an object
  if (typeof obj?.relationshipToVeteran === 'object') {
    // Iterate over keys in relationshipToVeteran object
    Object.keys(obj?.relationshipToVeteran).forEach(key => {
      // edge case for certifier relationship (generated by a checkboxgroup):
      if (obj?.relationshipToVeteran[key] === true) {
        rel = key; // e.g., `'spouse': true` yields `'spouse'`
      }
    });
  }
  // Check if otherRelationshipToVeteran is a string
  if (typeof obj?.otherRelationshipToVeteran === 'string') {
    rel = obj?.otherRelationshipToVeteran;
  }

  return rel;
}

// For each applicant, adjust organization of the object, add supporting documents array
function transformApplicants(applicants) {
  const uploadKeys = Array.from(
    new Set([
      ...(FILE_UPLOAD_ORDER || []),
      ...Object.keys(REQUIRED_FILES || {}),
    ]),
  );

  return (applicants || []).map(app => {
    let transformedApp = {
      ...app,
      ssnOrTin: app.applicantSSN ?? '',
      vetRelationship: transformRelationship(
        app.applicantRelationshipToSponsor || 'NA',
      ),
      // Collect uploads from ALL known keys, keep arrays only, drop falsy
      applicantSupportingDocuments: uploadKeys
        .map(k => app?.[k])
        .filter(Boolean)
        .filter(v => Array.isArray(v)),
    };

    transformedApp = adjustYearString(transformedApp);
    transformedApp.applicantAddress = concatStreets(
      transformedApp.applicantAddress,
    );
    return transformedApp;
  });
}

export default function transformForSubmit(formConfig, form) {
  /* 
  Remove view:applicantSSNArray BEFORE attempting to transform for submit:
  In Cypress tests, this array sometimes has items which are undefined,
  which throws an error in the formSystem `filterViewFields` method. Removing
  before we get to that point seems to fix the issue. This problem has not
  been observed outside of Cypress. 
  */
  // eslint-disable-next-line no-param-reassign
  form?.data?.applicants?.forEach(a => delete a['view:applicantSSNArray']);

  // delete form.data.['view:applicantSSNArray']
  const transformedData = JSON.parse(
    formsSystemTransformForSubmit(formConfig, form),
  );

  if (transformedData.sponsorAddress)
    transformedData.sponsorAddress = concatStreets(
      transformedData.sponsorAddress,
    );

  if (transformedData.certifierAddress)
    transformedData.certifierAddress = concatStreets(
      transformedData.certifierAddress,
    );

  const currentDate =
    fmtDate(new Date().toISOString().replace(/T.*/, '')) || '';

  const dataPostTransform = {
    veteran: {
      fullName: transformedData?.veteransFullName || {},
      ssnOrTin: transformedData?.ssn || '',
      dateOfBirth: fmtDate(transformedData?.sponsorDob) || '',
      phoneNumber: transformedData?.sponsorPhone || '',
      address: transformedData?.sponsorAddress || {},
      sponsorIsDeceased: transformedData?.sponsorIsDeceased,
      dateOfDeath: fmtDate(transformedData?.sponsorDOD) || '',
      // Find the first applicant with a date of marriage to sponsor
      dateOfMarriage:
        fmtDate(
          transformedData?.applicants?.find(
            a =>
              a?.applicantRelationshipToSponsor?.relationshipToVeteran ===
                'spouse' && a?.dateOfMarriageToSponsor !== undefined,
          )?.dateOfMarriageToSponsor,
        ) || '',
      isActiveServiceDeath: transformedData?.sponsorDeathConditions,
    },
    applicants: transformApplicants(transformedData.applicants ?? []),
    // If certifier is also applicant, we don't need to fill out the
    // bottom "Certification" section of the PDF:
    certification:
      transformedData?.certifierRole === 'applicant'
        ? { date: currentDate }
        : {
            date: currentDate,
            lastName: transformedData?.certifierName?.last || '',
            middleInitial: transformedData?.certifierName?.middle || '',
            firstName: transformedData?.certifierName?.first || '',
            phoneNumber: transformedData?.certifierPhone || '',
            // will produce string list of checkboxgroup keys (e.g., "spouse; child")
            relationship: trueKeysOnly(
              transformedData?.certifierRelationship?.relationshipToVeteran,
            ).join('; '),
            streetAddress:
              transformedData?.certifierAddress?.streetCombined || '',
            city: transformedData?.certifierAddress?.city || '',
            state: transformedData?.certifierAddress?.state || '',
            postalCode: transformedData?.certifierAddress?.postalCode || '',
          },
    supportingDocs: [],
    // Include everything we originally received
    rawData: transformedData,
  };

  // Flatten supporting docs for all applicants to a single array
  const supDocs = [];
  (dataPostTransform.applicants || []).forEach(app => {
    (app.applicantSupportingDocuments || []).forEach(doc => {
      if (Array.isArray(doc) && doc.length) {
        supDocs.push(
          ...doc
            .filter(Boolean)
            .map(file => ({ ...file, applicantName: app.applicantName })),
        );
      }
    });
  });

  // Set a top-level boolean indicating if any applicants are over 65
  dataPostTransform.hasApplicantOver65 = dataPostTransform.applicants.some(
    app => getAgeInYears(app.applicantDob) >= 65,
  );

  dataPostTransform.supportingDocs = [
    ...(Array.isArray(dataPostTransform.supportingDocs)
      ? dataPostTransform.supportingDocs
      : []),
    ...supDocs,
  ];
  dataPostTransform.certifierRole = transformedData.certifierRole;
  dataPostTransform.statementOfTruthSignature =
    transformedData.statementOfTruthSignature;
  // `primaryContactInfo` is who BE callback API emails if there's a notification event
  dataPostTransform.primaryContactInfo = {
    name: transformedData.certifierName,
    email: transformedData.certifierEmail,
    phone: transformedData.certifierPhone,
  };
  return JSON.stringify({
    ...dataPostTransform,
    formNumber: formConfig.formId,
  });
}
