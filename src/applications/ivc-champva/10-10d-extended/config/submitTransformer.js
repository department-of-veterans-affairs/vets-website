/* eslint-disable no-param-reassign */

// TODO: refactor so the eslint disable above isn't necessary
import { transformForSubmit as formsSystemTransformForSubmit } from 'platform/forms-system/src/js/helpers';
import {
  adjustYearString,
  concatStreets,
  getAgeInYears,
  getObjectsWithAttachmentId,
  toHash,
} from '../../shared/utilities';

// This submit transformer is a combination of the transformers that already
// exist for forms 10-10d and 10-7959c. It's been altered to support the new
// health insurance policy structure.
// TODO:
// - Remove redundancies
// - Refactor this transformer so it's less bloated

// Rearranges date string from YYYY-MM-DD to MM-DD-YYYY
function fmtDate(date) {
  return date?.length && date.length === 10
    ? `${date.slice(5)}-${date.slice(0, 4)}`
    : date;
}

// Returns list of object keys where obj[key] === true. Used
// to get the list of relationships a certifier has w/ the applicants:
function trueKeysOnly(obj) {
  return Object.keys(obj ?? {}).filter(k => obj[k] === true);
}

// Simplify a relationship object from (potentially) multiple nested objects to a single string
function transformRelationship(obj) {
  if (typeof obj === 'string') return obj;
  let rel = obj?.relationshipToVeteran;
  // Check if relationshipToVeteran is an object
  if (typeof obj?.relationshipToVeteran === 'object') {
    // Iterate over keys in relationshipToVeteran object
    Object.keys(obj?.relationshipToVeteran).forEach(key => {
      // edge case for certifier relationship (generated by a checkboxgroup):
      if (obj?.relationshipToVeteran[key] === true) {
        rel = key; // e.g., `'spouse': true` yields `'spouse'`
      }
    });
  }
  // Check if otherRelationshipToVeteran is a string
  if (typeof obj?.otherRelationshipToVeteran === 'string') {
    rel = obj?.otherRelationshipToVeteran;
  }

  return rel;
}

// This function maps health insurance policies to applicants
// so that when the backend receives the data it can generate
// OHI forms for all applicants where it applies.
function ohiTransformer(data) {
  const copyOfData = JSON.parse(JSON.stringify(data));

  // iterate over all policies
  copyOfData.healthInsurance.forEach(policy => {
    // list of hashes that correspond to applicants for this policy
    const keys = Object.keys(policy.healthcareParticipants).filter(
      k => policy.healthcareParticipants[k] === true,
    );
    //
    copyOfData.applicants
      .filter(a => keys.includes(toHash(a.applicantSSN)))
      .forEach(a => {
        // initialize
        a.healthInsurance = a.healthInsurance ? a.healthInsurance : [];

        a.applicantMedicareAdvantage = a.applicantMedicareClass === 'advantage';

        a.hasOtherHealthInsurance =
          a.applicantHasPrimary || a.applicantHasSecondary;

        if (a.applicantName?.middle) {
          a.applicantName.middle = a.applicantName?.middle?.charAt(0) ?? '';
        }

        // Combine all street strings for main address into one
        if (a.applicantAddress)
          a.applicantAddress = concatStreets(a.applicantAddress);

        // Build an array of insurance policies on the applicant
        a.healthInsurance.push(policy);
      });
  });

  // Get today's date as YYYY-MM-DD
  copyOfData.certificationDate = new Date().toISOString().replace(/T.*/, '');
  return copyOfData;
}

// For each applicant, adjust organization of the object, add supporting documents array
function transformApplicants(applicants) {
  const applicantsPostTransform = [];
  applicants.forEach(app => {
    let transformedApp = {
      ...app,
      ssnOrTin: app.applicantSSN ?? '',
      vetRelationship: transformRelationship(
        app.applicantRelationshipToSponsor || 'NA',
      ),
      // Grab any file upload properties from this applicant and combine into a
      // supporting documents array:
      applicantSupportingDocuments: getObjectsWithAttachmentId(
        app,
        'confirmationCode',
      ),
    };
    transformedApp = adjustYearString(transformedApp);
    transformedApp.applicantAddress = concatStreets(
      transformedApp.applicantAddress,
    );
    applicantsPostTransform.push(transformedApp);
  });
  return applicantsPostTransform;
}

export default function transformForSubmit(formConfig, form) {
  const transformedData = JSON.parse(
    formsSystemTransformForSubmit(formConfig, form),
  );

  if (transformedData.sponsorAddress)
    transformedData.sponsorAddress = concatStreets(
      transformedData.sponsorAddress,
    );

  if (transformedData.certifierAddress)
    transformedData.certifierAddress = concatStreets(
      transformedData.certifierAddress,
    );

  const currentDate =
    fmtDate(new Date().toISOString().replace(/T.*/, '')) || '';

  const dataPostTransform = ohiTransformer({
    veteran: {
      fullName: transformedData?.sponsorName || {},
      ssnOrTin: transformedData?.sponsorSsn?.ssn || '',
      vaClaimNumber: transformedData?.sponsorSsn?.vaFileNumber || '',
      dateOfBirth: fmtDate(transformedData?.sponsorDob) || '',
      phoneNumber: transformedData?.sponsorPhone || '',
      address: transformedData?.sponsorAddress || {},
      sponsorIsDeceased: transformedData?.sponsorIsDeceased,
      dateOfDeath: fmtDate(transformedData?.sponsorDOD) || '',
      // Find the first applicant with a date of marriage to sponsor
      dateOfMarriage:
        fmtDate(
          transformedData?.applicants?.find(
            a =>
              a?.applicantRelationshipToSponsor?.relationshipToVeteran ===
                'spouse' && a?.dateOfMarriageToSponsor !== undefined,
          )?.dateOfMarriageToSponsor,
        ) || '',
      isActiveServiceDeath: transformedData?.sponsorDeathConditions,
    },
    applicants: transformApplicants(transformedData.applicants ?? []),
    healthInsurance: transformedData.healthInsurance ?? [],
    // If certifier is also applicant, we don't need to fill out the
    // bottom "Certification" section of the PDF:
    certification:
      transformedData?.certifierRole === 'applicant'
        ? { date: currentDate }
        : {
            date: currentDate,
            lastName: transformedData?.certifierName?.last || '',
            middleInitial: transformedData?.certifierName?.middle || '',
            firstName: transformedData?.certifierName?.first || '',
            phoneNumber: transformedData?.certifierPhone || '',
            // will produce string list of checkboxgroup keys (e.g., "spouse; child")
            relationship: trueKeysOnly(
              transformedData?.certifierRelationship?.relationshipToVeteran,
            ).join('; '),
            streetAddress:
              transformedData?.certifierAddress?.streetCombined || '',
            city: transformedData?.certifierAddress?.city || '',
            state: transformedData?.certifierAddress?.state || '',
            postalCode: transformedData?.certifierAddress?.postalCode || '',
          },
    supportingDocs: [],
    // Include everything we originally received
    rawData: transformedData,
  });

  // Get supporting docs at the top level of the formdata
  dataPostTransform.supportingDocs = getObjectsWithAttachmentId(
    dataPostTransform,
    'confirmationCode',
  );
  // get supporting docs from healthInsurance policies
  dataPostTransform.healthInsurance.forEach(el => {
    getObjectsWithAttachmentId(el, 'confirmationCode').forEach(e =>
      dataPostTransform.supportingDocs.push(e),
    );
  });

  // Flatten supporting docs for all applicants to a single array
  const supDocs = [];
  dataPostTransform.applicants.forEach(app => {
    if (app.applicantSupportingDocuments.length > 0) {
      app.applicantSupportingDocuments.forEach(doc => {
        if (doc !== undefined && doc !== null) {
          // For clarity's sake, add applicant's name onto each file object:
          supDocs.push({
            ...doc,
            applicantName: app.applicantName,
          });
        }
      });
    }
  });

  // Set a top-level boolean indicating if any applicants are over 65
  dataPostTransform.hasApplicantOver65 = dataPostTransform.applicants.some(
    app => getAgeInYears(app.applicantDob) >= 65,
  );

  dataPostTransform.supportingDocs = dataPostTransform.supportingDocs
    .flat()
    .concat(supDocs);
  dataPostTransform.certifierRole = transformedData.certifierRole;
  dataPostTransform.statementOfTruthSignature =
    transformedData.statementOfTruthSignature;
  // `primaryContactInfo` is who BE callback API emails if there's a notification event
  dataPostTransform.primaryContactInfo = {
    name: transformedData.certifierName,
    email: transformedData.certifierEmail,
    phone: transformedData.certifierPhone,
  };
  return JSON.stringify({
    ...dataPostTransform,
    formNumber: formConfig.formId,
  });
}
