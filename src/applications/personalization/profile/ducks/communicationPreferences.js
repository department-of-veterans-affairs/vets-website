import { apiRequest } from '~/platform/utilities/api';

import { LOADING_STATES } from '../../common/constants';

// HELPERS
// Callback function to use with Array.filter
function communicationGroupsSorter(groupA, groupB) {
  // The lower the sorting priority value, the closer it is to the top of the
  // list, because lower numbers come first
  const groupSortingPriorities = {
    3: -1000, // group 3, "Your health care", should come first
  };
  function getCommunicationGroupSortingPriority(groupId) {
    return groupSortingPriorities[groupId] ?? groupId;
  }

  return (
    getCommunicationGroupSortingPriority(groupA.id) -
    getCommunicationGroupSortingPriority(groupB.id)
  );
}

// ACTION TYPES
const FETCH_STARTED = '@@profile/communicationPreferences/fetchStarted';
const FETCH_FAILED = '@@profile/communicationPreferences/fetchFailed';
const FETCH_COMPLETED = '@@profile/communicationPreferences/fetchCompleted';
const SAVE_STARTED = '@@profile/communicationPreferences/saveStarted';
const SAVE_FAILED = '@@profile/communicationPreferences/saveFailed';
const SAVE_COMPLETED = '@@profile/communicationPreferences/saveCompleted';
const TOGGLE_EDIT_MODE = '@@profile/communicationPreferences/toggleEditMode';

export const endpoint = '/profile/communication_preferences';

// ACTION CREATORS
const startFetch = () => {
  return { type: FETCH_STARTED };
};

const fetchCompleted = communicationGroups => {
  return { type: FETCH_COMPLETED, payload: communicationGroups };
};

const fetchFailed = errors => {
  return { type: FETCH_FAILED, errors };
};

const startSave = groupId => {
  return { type: SAVE_STARTED, payload: { groupId } };
};

const saveFailed = (groupId, errors) => {
  return { type: SAVE_FAILED, payload: { groupId, errors } };
};

const saveCompleted = groupId => {
  return { type: SAVE_COMPLETED, payload: { groupId } };
};

export const toggleEditMode = groupId => {
  return {
    type: TOGGLE_EDIT_MODE,
    payload: { groupId },
  };
};

export const fetchCommunicationPreferenceGroups = () => {
  return async dispatch => {
    dispatch(startFetch());

    try {
      const communicationPreferences = await apiRequest(endpoint);
      const { communicationGroups } = communicationPreferences.data.attributes;
      if (!communicationGroups) {
        throw new TypeError('communicationGroups is undefined');
      }
      dispatch(fetchCompleted(communicationGroups));
    } catch (error) {
      const errors = error.errors || [error];
      dispatch(fetchFailed(errors));
    }
  };
};

// accepts an array of "api call" objects we can easily use to make a bunch of
// apiRequest calls in parallel. Each `api call` object has a method, endpoint,
// and payload. These "api call" objects will be generated by a
// CommunicationChannel.getApiData() method
export const saveCommunicationPreferenceGroup = (groupId, apiCalls) => {
  return async dispatch => {
    dispatch(startSave(groupId));

    try {
      await Promise.all(
        apiCalls.map(callInfo => {
          return apiRequest(callInfo.endpoint, {
            method: callInfo.method,
            body: callInfo.payload,
            headers: { 'Content-Type': 'application/json' },
          });
        }),
      );
      dispatch(saveCompleted(groupId));
    } catch (error) {
      const errors = error.errors ?? [error];
      dispatch(saveFailed(groupId, errors));
    }
  };
};

// SELECTORS
export const selectGroups = state => {
  return state.groups;
};
export const selectGroupById = (state, groupId) => {
  return selectGroups(state).entities[groupId];
};
export const selectGroupUi = (state, groupId) => {
  return selectGroupById(state, groupId).ui;
};
export const selectIsGroupEditing = (state, groupId) => {
  return selectGroupUi(state, groupId).ui.isEditing;
};

// REDUCERS
function communicationGroupsReducer(accumulator, group) {
  const groupId = `group${group.id}`;
  accumulator.ids.push(groupId);
  const communicationGroup = {
    name: group.name,
    description: group.description,
    ui: {
      isEditing: false,
      updateStatus: LOADING_STATES.idle,
      errors: null,
    },
  };
  communicationGroup.items = group.communicationItems.map(item => {
    return `item${item.id}`;
  });
  accumulator.entities[groupId] = communicationGroup;
  return accumulator;
}

function communicationItemsReducer(accumulator, item) {
  const itemId = `item${item.id}`;
  accumulator.ids.push(itemId);
  const communicationItem = {
    name: item.name,
  };
  communicationItem.channels = item.communicationChannels.map(channel => {
    return `channel${item.id}-${channel.id}`;
  });
  accumulator.entities[itemId] = communicationItem;
  return accumulator;
}

function communicationChannelsReducer(accumulator, item) {
  const itemId = `item${item.id}`;
  item.communicationChannels.forEach(channel => {
    const channelId = `channel${item.id}-${channel.id}`;
    accumulator.ids.push(channelId);
    const communicationChannel = {
      channelType: channel.id,
      parentItem: itemId,
      isAllowed: channel.communicationPermission?.allowed ?? false,
      permissionId: channel.communicationPermission?.id ?? null,
    };
    accumulator.entities[channelId] = communicationChannel;
  });
  return accumulator;
}

// MAIN REDUCER
const initialState = {
  loadingStatus: LOADING_STATES.idle,
  loadingErrors: null,
  groups: {
    ids: [],
    entities: {},
  },
  items: {
    ids: [],
    entities: {},
  },
  channels: {
    ids: [],
    entities: {},
  },
};
export default function reducer(state = initialState, action = {}) {
  switch (action.type) {
    case FETCH_STARTED: {
      return { ...state, loadingStatus: LOADING_STATES.pending };
    }
    case FETCH_FAILED: {
      return {
        ...state,
        loadingStatus: LOADING_STATES.error,
        loadingErrors: action.errors,
      };
    }
    case FETCH_COMPLETED: {
      const communicationGroups = action.payload;
      // Array.sort sorts the array in place
      communicationGroups.sort(communicationGroupsSorter);
      // flat array of all communication items that exist across all groups
      const fetchedItems = communicationGroups.reduce((acc, group) => {
        return [...acc, ...group.communicationItems];
      }, []);
      // massaged communication group data to store in Redux
      const groups = communicationGroups.reduce(communicationGroupsReducer, {
        ids: [],
        entities: {},
      });
      // massaged communication items data to store in Redux
      const items = fetchedItems.reduce(communicationItemsReducer, {
        ids: [],
        entities: {},
      });
      // massaged communication channels data to store in Redux
      const channels = fetchedItems.reduce(communicationChannelsReducer, {
        ids: [],
        entities: {},
      });
      return {
        ...state,
        loadingStatus: LOADING_STATES.loaded,
        loadingErrors: null,
        groups,
        items,
        channels,
      };
    }
    case TOGGLE_EDIT_MODE: {
      const { groupId } = action.payload;
      const activeGroup = { ...selectGroupById(state, groupId) };
      activeGroup.isEditing = !activeGroup.isEditing;
      const newState = { ...state };
      newState.groups[groupId] = activeGroup;
      return newState;
    }
    case SAVE_STARTED: {
      const { groupId } = action.payload;
      const activeGroup = { ...selectGroupById(state, groupId) };
      activeGroup.ui.updateStatus = LOADING_STATES.pending;
      const newState = { ...state };
      newState.groups[groupId] = activeGroup;
      return newState;
    }
    case SAVE_FAILED: {
      const { groupId, errors } = action.payload;
      const activeGroup = { ...selectGroupById(state, groupId) };
      activeGroup.ui.updateStatus = LOADING_STATES.error;
      activeGroup.ui.errors = errors;
      const newState = { ...state };
      newState.groups[groupId] = activeGroup;
      return newState;
    }
    case SAVE_COMPLETED: {
      const { groupId } = action.payload;
      const activeGroup = { ...selectGroupById(state, groupId) };
      activeGroup.ui.updateStatus = LOADING_STATES.loaded;
      activeGroup.ui.isEditing = false;
      activeGroup.ui.errors = null;
      // TODO: maybe copy the wipSelections to savedSelections?
      const newState = { ...state };
      newState.groups[groupId] = activeGroup;
      return newState;
    }
    default: {
      return state;
    }
  }
}
