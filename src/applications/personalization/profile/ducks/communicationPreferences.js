import flatten from 'lodash/flatten';

import { apiRequest } from '~/platform/utilities/api';

import { LOADING_STATES } from '../../common/constants';

// HELPERS

// Callback function to use with Array.sort
// At present its only function is to
// make sure that the Your Health Care group appears first
function communicationGroupsSorter(groupA, groupB) {
  // The lower the sorting priority value, the closer it is to the top of the
  // list (because lower numbers come first). We'll use negative numbers to
  // override the group IDs that comes from the API.
  const groupSortingPriorities = {
    3: -1000, // group 3, "Your health care", should come first
  };
  function getCommunicationGroupSortingPriority(groupId) {
    return groupSortingPriorities[groupId] ?? groupId;
  }

  return (
    getCommunicationGroupSortingPriority(groupA.id) -
    getCommunicationGroupSortingPriority(groupB.id)
  );
}

// ACTION TYPES
const FETCH_STARTED = '@@profile/communicationPreferences/fetchStarted';
const FETCH_FAILED = '@@profile/communicationPreferences/fetchFailed';
const FETCH_SUCCEEDED = '@@profile/communicationPreferences/fetchSucceeded';
const SAVE_CHANNEL_STARTED =
  '@@profile/communicationPreferences/saveChannelStarted';
const SAVE_CHANNEL_FAILED =
  '@@profile/communicationPreferences/saveChannelFailed';
const SAVE_CHANNEL_SUCCEEDED =
  '@@profile/communicationPreferences/saveChannelSucceeded';

export const endpoint = '/profile/communication_preferences';

// ACTION CREATORS
const startFetch = () => {
  return { type: FETCH_STARTED };
};

const fetchSucceeded = communicationGroups => {
  return { type: FETCH_SUCCEEDED, payload: communicationGroups };
};

const fetchFailed = errors => {
  return { type: FETCH_FAILED, errors };
};

const startSaveChannel = (channelId, isAllowed) => {
  return { type: SAVE_CHANNEL_STARTED, payload: { channelId, isAllowed } };
};

const saveChannelFailed = (channelId, isAllowed, errors) => {
  return {
    type: SAVE_CHANNEL_FAILED,
    payload: { channelId, isAllowed, errors },
  };
};

const saveChannelSucceeded = (channelId, data) => {
  return { type: SAVE_CHANNEL_SUCCEEDED, payload: { channelId, data } };
};

export const fetchCommunicationPreferenceGroups = () => {
  return async dispatch => {
    dispatch(startFetch());

    try {
      const communicationPreferences = await apiRequest(endpoint);
      const { communicationGroups } = communicationPreferences.data.attributes;
      if (!communicationGroups) {
        throw new TypeError('communicationGroups is undefined');
      }
      dispatch(fetchSucceeded(communicationGroups));
    } catch (error) {
      const errors = error.errors || [error];
      dispatch(fetchFailed(errors));
    }
  };
};

// accepts an "api call" object we can use to easily make an apiRequest call.
// The `api call` object has a method, endpoint, and payload. The "api call"
// object will be generated by a CommunicationChannel.getApiData() method
export const saveCommunicationPreferenceChannel = (channelId, apiCallInfo) => {
  return async dispatch => {
    dispatch(startSaveChannel(channelId, apiCallInfo.isAllowed));

    try {
      const response = await apiRequest(apiCallInfo.endpoint, {
        method: apiCallInfo.method,
        body: JSON.stringify(apiCallInfo.payload),
        headers: { 'Content-Type': 'application/json' },
      });
      // It's possible that a 200 from the API is not _really_ a successful
      // call and we need to treat it like an error
      if (response.status !== 'COMPLETED_SUCCESS') {
        const error = new Error();
        error.errors = response.messages;
        // TODO: record something in GA or Sentry when a 200 "failure" happens
        throw error;
      }
      dispatch(saveChannelSucceeded(channelId, response.bio));
    } catch (error) {
      const errors = error.errors ?? [error];
      dispatch(saveChannelFailed(channelId, apiCallInfo.wasAllowed, errors));
    }
  };
};

// SELECTORS
export const selectGroups = state => {
  return state.groups;
};
export const selectGroupById = (state, groupId) => {
  return selectGroups(state).entities[groupId];
};
const selectItems = state => {
  return state.items;
};
export const selectItemById = (state, itemId) => {
  return selectItems(state).entities[itemId];
};
const selectChannels = state => {
  return state.channels;
};
export const selectChannelById = (state, channelId) => {
  return selectChannels(state).entities[channelId];
};
export const selectChannelUiById = (state, channelId) => {
  return selectChannelById(state, channelId).ui;
};

// The selectors below are specific to the business requirements for the
// Notification Settings section of the Profile

// Filters out the health care group if the user is not a patient
export const selectAvailableGroups = (state, { isPatient = false } = {}) => {
  const allGroups = selectGroups(state);
  return allGroups.ids.reduce(
    (acc, groupId) => {
      // remove the health care group (group3) if not a patient
      if (groupId === 'group3' && !isPatient) {
        return acc;
      } else {
        acc.ids.push(groupId);
        acc.entities[groupId] = allGroups.entities[groupId];
        return acc;
      }
    },
    {
      ids: [],
      entities: {},
    },
  );
};

// Makes a callback function to use with Array.filter()
export const makeRxTrackingItemFilter = facilities => {
  // 554: parent facility of Denver
  // 637: parent facility of Asheville
  // 983: test-only facility ID, used by user 36 among others
  const supportedFacilities = new Set(['554', '637', '983']);
  return itemId => {
    if (itemId === 'item4') {
      return facilities.some(facility => {
        return supportedFacilities.has(facility.facilityId);
      })
        ? itemId
        : null;
    }
    return itemId;
  };
};

// Filter out the items the user does not have access to
// 1. Filter out the Rx tracking item (item4) unless they are a patient at a
//    facility that supports the feature
export const selectAvailableItems = (
  state,
  { facilities = [], isPatient = false } = {},
) => {
  const availableGroups = selectAvailableGroups(state, { isPatient });
  const itemIds = flatten(
    availableGroups.ids.map(groupId => {
      return availableGroups.entities[groupId].items;
    }),
  ).filter(makeRxTrackingItemFilter(facilities));
  const itemEntities = itemIds.reduce((acc, itemId) => {
    acc[itemId] = selectItemById(state, itemId);
    return acc;
  }, {});
  return { ids: itemIds, entities: itemEntities };
};

// Filter out the channels the user doesn't have contact info for
export const selectAvailableChannels = (
  state,
  {
    facilities = [],
    hasMobilePhone = false,
    hasEmailAddress = false,
    isPatient = false,
  } = {},
) => {
  const availableItems = selectAvailableItems(state, { isPatient, facilities });
  const availableItemsChannels = flatten(
    availableItems.ids.map(itemId => {
      return availableItems.entities[itemId].channels;
    }),
  );
  return availableItemsChannels.reduce(
    (acc, channelId) => {
      const channel = selectChannelById(state, channelId);
      const { channelType } = channel;
      if (
        (channelType === 1 && hasMobilePhone) ||
        (channelType === 2 && hasEmailAddress)
      ) {
        acc.ids.push(channelId);
        acc.entities[channelId] = channel;
      }
      return acc;
    },
    { ids: [], entities: {} },
  );
};

export const selectChannelsWithoutSelection = (
  state,
  {
    facilities = [],
    hasMobilePhone = false,
    hasEmailAddress = false,
    isPatient = false,
  } = {},
) => {
  const availableChannels = selectAvailableChannels(state, {
    facilities,
    isPatient,
    hasMobilePhone,
    hasEmailAddress,
  });
  return availableChannels.ids.reduce(
    (acc, channelId) => {
      if (availableChannels.entities[channelId].permissionId === null) {
        acc.ids.push(channelId);
        acc.entities[channelId] = selectChannelById(state, channelId);
      }
      return acc;
    },
    {
      ids: [],
      entities: {},
    },
  );
};

// REDUCERS
function communicationGroupsReducer(accumulator, group) {
  const groupId = `group${group.id}`;
  accumulator.ids.push(groupId);
  const communicationGroup = {
    name: group.name,
    description: group.description,
  };
  communicationGroup.items = group.communicationItems.map(item => {
    return `item${item.id}`;
  });
  accumulator.entities[groupId] = communicationGroup;
  return accumulator;
}

function communicationItemsReducer(accumulator, item) {
  const itemId = `item${item.id}`;
  accumulator.ids.push(itemId);
  const communicationItem = {
    name: item.name,
  };
  communicationItem.channels = item.communicationChannels.map(channel => {
    return `channel${item.id}-${channel.id}`;
  });
  accumulator.entities[itemId] = communicationItem;
  return accumulator;
}

function communicationChannelsReducer(accumulator, item) {
  const itemId = `item${item.id}`;
  item.communicationChannels.forEach(channel => {
    const channelId = `channel${item.id}-${channel.id}`;
    accumulator.ids.push(channelId);
    const communicationChannel = {
      channelType: channel.id,
      parentItem: itemId,
      isAllowed: channel.communicationPermission?.allowed ?? null,
      permissionId: channel.communicationPermission?.id ?? null,
      ui: {
        updateStatus: LOADING_STATES.idle,
        errors: null,
      },
    };
    accumulator.entities[channelId] = communicationChannel;
  });
  return accumulator;
}

// MAIN REDUCER
const initialState = {
  loadingStatus: LOADING_STATES.idle,
  loadingErrors: null,
  groups: {
    ids: [],
    entities: {},
  },
  items: {
    ids: [],
    entities: {},
  },
  channels: {
    ids: [],
    entities: {},
  },
};
export default function reducer(state = initialState, action = {}) {
  switch (action.type) {
    case FETCH_STARTED: {
      return { ...state, loadingStatus: LOADING_STATES.pending };
    }
    case FETCH_FAILED: {
      return {
        ...state,
        loadingStatus: LOADING_STATES.error,
        loadingErrors: action.errors,
      };
    }
    case FETCH_SUCCEEDED: {
      const communicationGroups = action.payload;
      // Array.sort sorts the array in place
      communicationGroups.sort(communicationGroupsSorter);
      // flat array of all communication items that exist across all groups
      const fetchedItems = communicationGroups.reduce((acc, group) => {
        return [...acc, ...group.communicationItems];
      }, []);
      // massaged communication group data to store in Redux
      const groups = communicationGroups.reduce(communicationGroupsReducer, {
        ids: [],
        entities: {},
      });
      // massaged communication items data to store in Redux
      const items = fetchedItems.reduce(communicationItemsReducer, {
        ids: [],
        entities: {},
      });
      // massaged communication channels data to store in Redux
      const channels = fetchedItems.reduce(communicationChannelsReducer, {
        ids: [],
        entities: {},
      });
      return {
        ...state,
        loadingStatus: LOADING_STATES.loaded,
        loadingErrors: null,
        groups,
        items,
        channels,
      };
    }
    case SAVE_CHANNEL_STARTED: {
      const { channelId, isAllowed } = action.payload;
      const updatedChannel = { ...selectChannelById(state, channelId) };
      updatedChannel.isAllowed = isAllowed;
      updatedChannel.ui = {
        ...updatedChannel.ui,
        updateStatus: LOADING_STATES.pending,
      };
      const newState = { ...state };
      newState.channels.entities = { ...newState.channels.entities };
      newState.channels.entities[channelId] = { ...updatedChannel };
      return newState;
    }
    case SAVE_CHANNEL_SUCCEEDED: {
      const { channelId, data } = action.payload;
      const updatedChannel = { ...selectChannelById(state, channelId) };
      updatedChannel.isAllowed = data.allowed;
      updatedChannel.permissionId = data.communicationPermissionId;
      updatedChannel.ui = {
        ...updatedChannel.ui,
        updateStatus: LOADING_STATES.loaded,
        errors: null,
      };
      const newState = { ...state };
      newState.channels.entities[channelId] = { ...updatedChannel };
      return newState;
    }
    case SAVE_CHANNEL_FAILED: {
      const { channelId, errors, isAllowed } = action.payload;
      const updatedChannel = { ...selectChannelById(state, channelId) };
      updatedChannel.isAllowed = isAllowed;
      updatedChannel.ui = {
        ...updatedChannel.ui,
        updateStatus: LOADING_STATES.error,
        errors,
      };
      const newState = { ...state };
      newState.channels.entities[channelId] = { ...updatedChannel };
      return newState;
    }
    default: {
      return state;
    }
  }
}
