import { apiRequest } from '~/platform/utilities/api';

import { LOADING_STATES } from '../../common/constants';

// HELPERS

// Callback function to use with Array.sort
// At present its only function is to
// make sure that the Your Health Care group appears first
function communicationGroupsSorter(groupA, groupB) {
  // The lower the sorting priority value, the closer it is to the top of the
  // list (because lower numbers come first). We'll use negative numbers to
  // override the group IDs that comes from the API.
  const groupSortingPriorities = {
    3: -1000, // group 3, "Your health care", should come first
  };
  function getCommunicationGroupSortingPriority(groupId) {
    return groupSortingPriorities[groupId] ?? groupId;
  }

  return (
    getCommunicationGroupSortingPriority(groupA.id) -
    getCommunicationGroupSortingPriority(groupB.id)
  );
}

// ACTION TYPES
const FETCH_STARTED = '@@profile/communicationPreferences/fetchStarted';
const FETCH_FAILED = '@@profile/communicationPreferences/fetchFailed';
const FETCH_SUCCEEDED = '@@profile/communicationPreferences/fetchSucceeded';
const SAVE_CHANNEL_STARTED =
  '@@profile/communicationPreferences/saveChannelStarted';
const SAVE_CHANNEL_FAILED =
  '@@profile/communicationPreferences/saveChannelFailed';
const SAVE_CHANNEL_SUCCEEDED =
  '@@profile/communicationPreferences/saveChannelSucceeded';

export const endpoint = '/profile/communication_preferences';

// ACTION CREATORS
const startFetch = () => {
  return { type: FETCH_STARTED };
};

const fetchSucceeded = communicationGroups => {
  return { type: FETCH_SUCCEEDED, payload: communicationGroups };
};

const fetchFailed = errors => {
  return { type: FETCH_FAILED, errors };
};

const startSaveChannel = (channelId, isAllowed) => {
  return { type: SAVE_CHANNEL_STARTED, payload: { channelId, isAllowed } };
};

const saveChannelFailed = (channelId, isAllowed, errors) => {
  return {
    type: SAVE_CHANNEL_FAILED,
    payload: { channelId, isAllowed, errors },
  };
};

const saveChannelSucceeded = (channelId, data) => {
  return { type: SAVE_CHANNEL_SUCCEEDED, payload: { channelId, data } };
};

export const fetchCommunicationPreferenceGroups = () => {
  return async dispatch => {
    dispatch(startFetch());

    try {
      const communicationPreferences = await apiRequest(endpoint);
      const { communicationGroups } = communicationPreferences.data.attributes;
      if (!communicationGroups) {
        throw new TypeError('communicationGroups is undefined');
      }
      dispatch(fetchSucceeded(communicationGroups));
    } catch (error) {
      const errors = error.errors || [error];
      dispatch(fetchFailed(errors));
    }
  };
};

// accepts an "api call" object we can use to easily make an apiRequest call.
// The `api call` object has a method, endpoint, and payload. The "api call"
// object will be generated by a CommunicationChannel.getApiData() method
export const saveCommunicationPreferenceChannel = (channelId, apiCallInfo) => {
  return async dispatch => {
    dispatch(startSaveChannel(channelId, apiCallInfo.isAllowed));

    try {
      const response = await apiRequest(apiCallInfo.endpoint, {
        method: apiCallInfo.method,
        body: JSON.stringify(apiCallInfo.payload),
        headers: { 'Content-Type': 'application/json' },
      });
      // It's possible that a 200 from the API is not _really_ a successful
      // call and we need to treat it like an error
      if (response.status !== 'COMPLETED_SUCCESS') {
        const error = new Error();
        error.errors = response.messages;
        // TODO: record something in GA or Sentry when a 200 "failure" happens
        throw error;
      }
      dispatch(saveChannelSucceeded(channelId, response.bio));
    } catch (error) {
      const errors = error.errors ?? [error];
      dispatch(saveChannelFailed(channelId, apiCallInfo.wasAllowed, errors));
    }
  };
};

// SELECTORS
export const selectGroups = state => {
  return state.groups;
};
export const selectGroupById = (state, groupId) => {
  return selectGroups(state).entities[groupId];
};
const selectItems = state => {
  return state.items;
};
export const selectItemById = (state, itemId) => {
  return selectItems(state).entities[itemId];
};
const selectChannels = state => {
  return state.channels;
};
export const selectChannelById = (state, channelId) => {
  return selectChannels(state).entities[channelId];
};
export const selectChannelUiById = (state, channelId) => {
  return selectChannelById(state, channelId).ui;
};

// REDUCERS
function communicationGroupsReducer(accumulator, group) {
  const groupId = `group${group.id}`;
  accumulator.ids.push(groupId);
  const communicationGroup = {
    name: group.name,
    description: group.description,
  };
  communicationGroup.items = group.communicationItems.map(item => {
    return `item${item.id}`;
  });
  accumulator.entities[groupId] = communicationGroup;
  return accumulator;
}

function communicationItemsReducer(accumulator, item) {
  const itemId = `item${item.id}`;
  accumulator.ids.push(itemId);
  const communicationItem = {
    name: item.name,
  };
  communicationItem.channels = item.communicationChannels.map(channel => {
    return `channel${item.id}-${channel.id}`;
  });
  accumulator.entities[itemId] = communicationItem;
  return accumulator;
}

function communicationChannelsReducer(accumulator, item) {
  const itemId = `item${item.id}`;
  item.communicationChannels.forEach(channel => {
    const channelId = `channel${item.id}-${channel.id}`;
    accumulator.ids.push(channelId);
    const communicationChannel = {
      channelType: channel.id,
      parentItem: itemId,
      isAllowed: channel.communicationPermission?.allowed ?? null,
      permissionId: channel.communicationPermission?.id ?? null,
      ui: {
        updateStatus: LOADING_STATES.idle,
        errors: null,
      },
    };
    accumulator.entities[channelId] = communicationChannel;
  });
  return accumulator;
}

// MAIN REDUCER
const initialState = {
  loadingStatus: LOADING_STATES.idle,
  loadingErrors: null,
  groups: {
    ids: [],
    entities: {},
  },
  items: {
    ids: [],
    entities: {},
  },
  channels: {
    ids: [],
    entities: {},
  },
};
export default function reducer(state = initialState, action = {}) {
  switch (action.type) {
    case FETCH_STARTED: {
      return { ...state, loadingStatus: LOADING_STATES.pending };
    }
    case FETCH_FAILED: {
      return {
        ...state,
        loadingStatus: LOADING_STATES.error,
        loadingErrors: action.errors,
      };
    }
    case FETCH_SUCCEEDED: {
      const communicationGroups = action.payload;
      // Array.sort sorts the array in place
      communicationGroups.sort(communicationGroupsSorter);
      // flat array of all communication items that exist across all groups
      const fetchedItems = communicationGroups.reduce((acc, group) => {
        return [...acc, ...group.communicationItems];
      }, []);
      // massaged communication group data to store in Redux
      const groups = communicationGroups.reduce(communicationGroupsReducer, {
        ids: [],
        entities: {},
      });
      // massaged communication items data to store in Redux
      const items = fetchedItems.reduce(communicationItemsReducer, {
        ids: [],
        entities: {},
      });
      // massaged communication channels data to store in Redux
      const channels = fetchedItems.reduce(communicationChannelsReducer, {
        ids: [],
        entities: {},
      });
      return {
        ...state,
        loadingStatus: LOADING_STATES.loaded,
        loadingErrors: null,
        groups,
        items,
        channels,
      };
    }
    case SAVE_CHANNEL_STARTED: {
      const { channelId, isAllowed } = action.payload;
      const updatedChannel = { ...selectChannelById(state, channelId) };
      updatedChannel.isAllowed = isAllowed;
      updatedChannel.ui = {
        ...updatedChannel.ui,
        updateStatus: LOADING_STATES.pending,
      };
      const newState = { ...state };
      newState.channels.entities = { ...newState.channels.entities };
      newState.channels.entities[channelId] = { ...updatedChannel };
      return newState;
    }
    case SAVE_CHANNEL_SUCCEEDED: {
      const { channelId, data } = action.payload;
      const updatedChannel = { ...selectChannelById(state, channelId) };
      updatedChannel.isAllowed = data.allowed;
      updatedChannel.permissionId = data.communicationPermissionId;
      updatedChannel.ui = {
        ...updatedChannel.ui,
        updateStatus: LOADING_STATES.loaded,
        errors: null,
      };
      const newState = { ...state };
      newState.channels.entities[channelId] = { ...updatedChannel };
      return newState;
    }
    case SAVE_CHANNEL_FAILED: {
      const { channelId, errors, isAllowed } = action.payload;
      const updatedChannel = { ...selectChannelById(state, channelId) };
      updatedChannel.isAllowed = isAllowed;
      updatedChannel.ui = {
        ...updatedChannel.ui,
        updateStatus: LOADING_STATES.error,
        errors,
      };
      const newState = { ...state };
      newState.channels.entities[channelId] = { ...updatedChannel };
      return newState;
    }
    default: {
      return state;
    }
  }
}
