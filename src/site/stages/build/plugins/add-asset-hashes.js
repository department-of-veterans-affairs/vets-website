/* eslint-disable no-continue, no-param-reassign */

const environments = require('../../../constants/environments');

const FILE_MANIFEST_FILENAME = 'generated/file-manifest.json';

const TEAMSITE_INJECTION_BUNDLE_FILES = [
  'proxy-rewrite.entry.js',
  'styleConsolidated.css',
  'static-pages.css',
  'vendor.entry.js',
  'polyfills.entry.js',
];

function addAssetHashes(buildOptions) {
  const isDevBuild = [environments.LOCALHOST, environments.VAGOVDEV].includes(
    buildOptions.buildtype,
  );

  if (isDevBuild) {
    const noop = () => {};
    return noop;
  }

  return (files, metalsmith, done) => {
    const fileManifest = files[FILE_MANIFEST_FILENAME];

    if (!fileManifest) {
      throw new Error('file-manifest.json (generated by Webpack) not found!');
    }

    const entryNamesDictionary = new Map(
      Object.entries(JSON.parse(fileManifest.contents)),
    );

    for (const fileName of Object.keys(files)) {
      const file = files[fileName];

      const { dom } = file;
      if (!dom) continue;

      dom('script[data-entry-name],link[data-entry-name]').each((index, el) => {
        const $el = dom(el);
        const entryName = $el.data('entryName');
        const attribute = $el.is('script') ? 'src' : 'href';
        const hashedEntryName = entryNamesDictionary.get(entryName);

        $el.attr(attribute, hashedEntryName);

        file.modified = true;
      });
    }

    for (const unhashedFileName of TEAMSITE_INJECTION_BUNDLE_FILES) {
      const hashedFileName = entryNamesDictionary.get(unhashedFileName);
      const file = files[hashedFileName];

      if (!file) continue;

      files[`generated/${unhashedFileName}`] = file;
    }

    done();
  };
}

module.exports = addAssetHashes;
