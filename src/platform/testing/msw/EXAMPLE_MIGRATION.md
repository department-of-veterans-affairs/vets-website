# Example: Migrating a Real Test to MSW

This document shows a step-by-step migration of an actual mhv-medications test from cy.intercept to MSW.

## Original Test (Using cy.intercept)

**File:** `medications-active-status-definition-dropdown-details-page.cypress.spec.js`

```javascript
import MedicationsSite from './med_site/MedicationsSite';
import MedicationsListPage from './pages/MedicationsListPage';
import prescriptionRefillDetails from './fixtures/prescription-refill-button-details-page.json';
import MedicationsDetailsPage from './pages/MedicationsDetailsPage';
import rxList from './fixtures/listOfPrescriptions.json';

describe('Medications Details Page Status DropDown', () => {
  it('visits Medications Details Page Active Status DropDown', () => {
    const site = new MedicationsSite();
    const listPage = new MedicationsListPage();
    const detailsPage = new MedicationsDetailsPage();
    const cardNumber = 1;
    
    // Uses cy.intercept internally with hard-coded fixtures
    site.login();
    
    // Visits page with fixture data
    listPage.visitMedicationsListPageURL(rxList);
    
    cy.injectAxe();
    cy.axeCheck('main');
    
    detailsPage.clickMedicationDetailsLink(
      prescriptionRefillDetails,
      cardNumber,
    );
    detailsPage.clickWhatDoesThisStatusMeanDropDown();
    detailsPage.verifyActiveStatusDropDownDefinition();
  });
});
```

### Problems with Original:

1. **Hard-coded fixtures** - `rxList`, `prescriptionRefillDetails` are JSON files
2. **Not reusable** - Can't use same data in unit tests or local dev
3. **Maintenance burden** - Update fixtures when API changes
4. **Unclear intent** - What state does this test? Active? Refillable?
5. **Hidden mocking** - `site.login()` does cy.intercept internally

## Migrated Test (Using MSW)

```javascript
import MedicationsSiteMSW from './helpers/MedicationsSiteMSW';
import MedicationsDetailsPage from './pages/MedicationsDetailsPage';
import { scenarios } from '@department-of-veterans-affairs/platform-testing/msw/scenarios';

describe('Medications Details Page Status DropDown', () => {
  const site = new MedicationsSiteMSW();
  const detailsPage = new MedicationsDetailsPage();

  afterEach(() => {
    site.cleanup();
  });

  it('displays Active status dropdown definition', () => {
    // Clear, declarative scenario
    site.login({ prescriptionCount: 5 });
    
    // Load specific prescription state
    cy.loadMswScenario([
      scenarios.medications.singlePrescription({
        dispStatus: 'Active',
        isRefillable: true,
      }),
    ]);
    
    // Visit list page
    cy.visit('/my-health/medications');
    
    cy.injectAxe();
    cy.axeCheck('main');
    
    // Click first prescription
    cy.get('[data-testid="rx-card"]')
      .first()
      .find('a')
      .first()
      .click();
    
    // Verify details page
    cy.url().should('include', '/prescription/');
    
    // Interact with dropdown
    detailsPage.clickWhatDoesThisStatusMeanDropDown();
    detailsPage.verifyActiveStatusDropDownDefinition();
  });
});
```

### Improvements:

1. ✅ **Clear intent** - Scenario name shows it's testing Active status
2. ✅ **No fixtures** - Data generated by MSW
3. ✅ **Reusable** - Same scenario works in unit tests
4. ✅ **Flexible** - Easy to change count, status, attributes
5. ✅ **Explicit** - MSW scenario visible in test

## Step-by-Step Migration

### Step 1: Identify Current Mocking

Original test uses:
- `MedicationsSite.login()` → cy.intercept for user, toggles, prescriptions
- `visitMedicationsListPageURL(rxList)` → cy.intercept with fixture
- `prescriptionRefillDetails` → another fixture

### Step 2: Create MSW Scenarios

These already exist in `scenarios/medications.js`:

```javascript
export const medications = {
  withActiveRx: (options = {}) => [
    prescriptionsHandler({ status: 'Active', ...options }),
    prescriptionDetailsHandler({ dispStatus: 'Active' }),
    refillablePrescriptionsHandler(),
  ],
  
  singlePrescription: (attrs = {}) => [
    prescriptionDetailsHandler(attrs),
  ],
};
```

### Step 3: Replace Test Helper

**Before:**
```javascript
const site = new MedicationsSite();
site.login(); // Uses cy.intercept internally
```

**After:**
```javascript
const site = new MedicationsSiteMSW();
site.login({ prescriptionCount: 5 }); // Uses MSW
```

### Step 4: Remove Fixture Imports

**Before:**
```javascript
import prescriptionRefillDetails from './fixtures/prescription-refill-button-details-page.json';
import rxList from './fixtures/listOfPrescriptions.json';
```

**After:**
```javascript
// No imports needed! MSW generates data
```

### Step 5: Replace cy.intercept with Scenarios

**Before:**
```javascript
listPage.visitMedicationsListPageURL(rxList); // Internally does cy.intercept
```

**After:**
```javascript
cy.loadMswScenario([
  scenarios.medications.withActiveRx({ count: 5 }),
]);
cy.visit('/my-health/medications');
```

### Step 6: Add Cleanup

```javascript
afterEach(() => {
  site.cleanup(); // Reset MSW handlers
});
```

## Before/After Comparison

### Test Clarity

**Before:**
```javascript
site.login();
listPage.visitMedicationsListPageURL(rxList);
```
*What does rxList contain? How many prescriptions? What status?*

**After:**
```javascript
site.login({ prescriptionCount: 5 });
cy.loadMswScenario([
  scenarios.medications.withActiveRx(),
]);
```
*Clear: 5 active prescriptions*

### Flexibility

**Before:**
```javascript
// To test with 3 prescriptions, need to:
// 1. Create new fixture file
// 2. Import it
// 3. Update all tests using it
```

**After:**
```javascript
// Just change the parameter
site.login({ prescriptionCount: 3 });
```

### Maintenance

**Before:**
```javascript
// API changes → update multiple fixture files
// fixtures/rxList.json
// fixtures/prescriptionRefillDetails.json
// fixtures/emptyList.json
// ... 20+ fixture files
```

**After:**
```javascript
// API changes → update one handler
// msw/handlers/medications/prescriptions.js
// All tests automatically updated
```

## Unit Test Migration Example

### Original (Using mockFetch)

```javascript
import { mockFetch, resetFetch } from '@department-of-veterans-affairs/platform-testing/helpers';

describe('FillRefillButton', () => {
  beforeEach(() => {
    mockFetch();
  });

  afterEach(() => {
    resetFetch();
  });

  it('dispatches fillPrescription action', async () => {
    const screen = setup();
    const fillButton = await screen.findByTestId('refill-request-button');
    fireEvent.click(fillButton);
    
    await waitFor(() => {
      expect(screen.getByText('Submitting your request...')).to.exist;
    });
  });
});
```

### Migrated (Using MSW)

```javascript
import { server } from '@department-of-veterans-affairs/platform-testing/msw/server';
import { scenarios } from '@department-of-veterans-affairs/platform-testing/msw/scenarios';

describe('FillRefillButton', () => {
  // server.listen(), resetHandlers(), close() are automatic from server.js

  it('dispatches fillPrescription action', async () => {
    // Override default scenario if needed
    server.use(
      ...scenarios.medications.refillSuccess(),
    );

    const screen = setup();
    const fillButton = await screen.findByTestId('refill-request-button');
    fireEvent.click(fillButton);
    
    await waitFor(() => {
      expect(screen.getByText('Submitting your request...')).to.exist;
    });
  });

  it('handles refill failure', async () => {
    // Different scenario for failure case
    server.use(
      ...scenarios.medications.refillFailure(),
    );

    const screen = setup();
    const fillButton = await screen.findByTestId('refill-request-button');
    fireEvent.click(fillButton);
    
    await waitFor(() => {
      expect(screen.getByText('We didn't get your request')).to.exist;
    });
  });
});
```

## Local Dev Migration Example

### Original (Using mocker-api)

**File:** `mocks/api/index.js`

```javascript
const delay = require('mocker-api/lib/delay');
const prescriptions = require('./mhv-api/prescriptions/index');

const responses = {
  'GET /my_health/v1/prescriptions': (_req, res) => {
    setTimeout(() => {
      res.json(prescriptions.generateMockPrescriptions());
    }, 2250);
  },
  
  'GET /my_health/v1/prescriptions/:id': (req, res) => {
    const { id } = req.params;
    setTimeout(() => {
      res.json({ data: prescriptions.mockPrescription(id) });
    }, 2250);
  },
};

module.exports = delay(responses, 0);
```

**Usage:** `yarn mock-api --responses mocks/api/index.js`

### Migrated (Using MSW)

**File:** `app-entry.jsx`

```javascript
import environment from 'platform/utilities/environment';

// ... other imports

// Start MSW in development
if (environment.isLocalhost()) {
  import('@department-of-veterans-affairs/platform-testing/msw/browser').then(
    ({ worker }) => {
      worker.start({
        onUnhandledRequest: 'warn',
        quiet: false, // See requests in console
      });
      
      // Optional: Load specific scenario
      import('@department-of-veterans-affairs/platform-testing/msw/scenarios').then(
        ({ scenarios }) => {
          worker.use(...scenarios.medications.withActiveRx({ count: 15 }));
        },
      );
    },
  );
}

// ... rest of app entry
```

**Usage:** `yarn watch --env entry=medications` (MSW auto-starts)

### Benefits:

1. **No separate mock server** - Runs in browser, same origin
2. **Hot reload** - Change scenarios without restart
3. **Visible in DevTools** - See all mocked requests
4. **Same as tests** - Share scenarios with Cypress/unit tests
5. **Easy switching** - Change scenarios via console

```javascript
// In browser console:
import('/platform/testing/msw/scenarios').then(({ scenarios }) => {
  window.mswWorker.use(...scenarios.medications.empty());
  window.location.reload();
});
```

## Measuring Success

### Before Migration

```
Test file size: 120 lines
Fixture files: 5 (totaling 500 lines JSON)
Test clarity: 3/10 (hard to understand what's being tested)
Reusability: 0% (can't share with unit tests or dev)
Maintenance: High (update 5 files when API changes)
Debugging: Difficult (fixtures not visible in DevTools)
```

### After Migration

```
Test file size: 85 lines (-29%)
Fixture files: 0 (removed all)
Test clarity: 8/10 (scenarios clearly show intent)
Reusability: 100% (scenarios work everywhere)
Maintenance: Low (update 1 handler when API changes)
Debugging: Easy (visible in DevTools, can inspect in console)
```

## Common Migration Patterns

### Pattern 1: Simple Data Replacement

```javascript
// Before
cy.intercept('GET', '/api/data', { fixture: 'data.json' });

// After
cy.loadMswScenario([dataHandler({ count: 10 })]);
```

### Pattern 2: Error Testing

```javascript
// Before
cy.intercept('GET', '/api/data', { statusCode: 500, body: { errors: [...] } });

// After
cy.loadMswScenario([scenarios.data.error(500)]);
```

### Pattern 3: Dynamic Data

```javascript
// Before
cy.intercept('GET', '/api/data', (req) => {
  req.reply({
    body: generateData(req.query.count),
  });
});

// After
cy.loadMswScenario([
  dataHandler({ count: parseInt(req.url.searchParams.get('count')) }),
]);
```

### Pattern 4: Sequential Responses

```javascript
// Before
let callCount = 0;
cy.intercept('GET', '/api/data', (req) => {
  callCount++;
  if (callCount === 1) {
    req.reply({ body: { data: [] } });
  } else {
    req.reply({ body: { data: [...] } });
  }
});

// After
server.use(
  rest.get('/api/data', (req, res, ctx) => {
    const callCount = req.url.searchParams.get('page') || 1;
    if (callCount === '1') {
      return res(ctx.json({ data: [] }));
    }
    return res(ctx.json({ data: [...] }));
  }),
);
```

## Checklist for Migration

- [ ] Identify all cy.intercept calls in test
- [ ] Find corresponding mocker-api routes
- [ ] Check if MSW handler exists
  - [ ] Yes: Use existing handler
  - [ ] No: Create new handler
- [ ] Create scenario if needed
- [ ] Update test to use cy.loadMswScenario
- [ ] Remove fixture imports
- [ ] Add afterEach cleanup
- [ ] Run test to verify
- [ ] Check accessibility (cy.axeCheck)
- [ ] Commit changes

## Tips

1. **Start small** - Migrate one test, verify it works, then do more
2. **Use scenarios** - Don't create ad-hoc handlers in tests
3. **Keep cy.intercept for spying** - Don't remove all cy.intercept
4. **Test incrementally** - Run test after each change
5. **Reuse handlers** - Look for existing handlers before creating new ones
6. **Document scenarios** - Add JSDoc comments to explain scenario purpose

## Conclusion

Migrating to MSW reduces code, improves clarity, enables reuse, and simplifies maintenance. The initial migration takes time, but the long-term benefits are significant.

**Estimated time per test:** 15-30 minutes  
**ROI:** Positive after ~10 tests migrated
